---
title: Pre-processing of *Caenorhabditis* spp. bulk RNA-seq for inclusion in *Caenorhabditis* RNA-Seq Browser
author: "Astra S. Bryant, PhD"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  pdf_document:
    df_print: paged
    toc: true
    toc_depth: 3
    number_sections: true
---

# Introduction
The goal of this file is to arrange gene-centric *C. elegans* RNA-seq data from the modENCODE project ([Gerstein *et al* 2010](https://pubmed.ncbi.nlm.nih.gov/21177976/), provided by LaDeana Hillier in Dr. Bob Waterson's lab at UW). 

## Update Notes  


# Pre-processing Methods Overview  
Data set is imported into R and annotated with information from WormBase ParaSite BiomaRT. Annotation information includes: UniProtKB number, Interpro terms, GO terms, and general Description information. Annotation information is be saved as an R object that is passed to a Shiny Web App for downstream browsing and on-demand analysis. Note: raw count data could be saved as a digital gene expression list if desired (not currently done).  


Raw reads were quantified as counts per million using the EdgeR package, then filtered to remove transcripts with low counts (less than 1 count-per-million in at least 3 samples). A list of discarded genes and their expression values across life stages is saved. Non-discarded gene values are normalized using the trimmed mean of M-values method (TMM, [Robinson and Oshlack](https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-3-r25) ) to permit between-samples comparisons. The mean-variance relationship was modeled using a precision weights approach [Law *et al* 2014](https://genomebiology.biomedcentral.com/articles/10.1186/gb-2014-15-2-r29).  

A variance-stabilized DGEList object is saved; this file is passed to a Shiny Web App for downstream browsing and on-demand analysis.  

# Load dependencies
```{r dependencies, eval=TRUE, echo = FALSE}
if (!require("BiocManager", quietly = TRUE)) install.packages("BiocManager")
if (!require("tximport", quietly = TRUE)) BiocManager::install("tximport", ask = FALSE)
if (!require("ensembldb", quietly = TRUE)) BiocManager::install("ensembldb", ask = FALSE)
if (!require("biomaRt", quietly = TRUE)) BiocManager::install("biomaRt", ask = FALSE)
if (!require("pacman", quietly = TRUE)) install.packages("pacman")
pacman::p_load("tidyverse","magrittr","edgeR","matrixStats","cowplot","ggthemes","RColorBrewer","gprofiler2","limma","tximport", "ensembldb", "biomaRt")

# Check for presence of output folder, generate if it doesn't exist
output.path <- "./Outputs"
if (!dir.exists(output.path)){
  dir.create(output.path)
}
```

# Results/Analysis  
Note: Code chunks are collated and echoed at the end of the document in Appendix I.
```{r setup, echo = FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

## Import log2 count data into R  
Import Kallisto transcript counts into R using Tximport. Counts are generated from abundance files using the `lengthScaledTPM` option. This code chunk generates and saves an object containing the transcripts per million data. In subsequent chunks, that file is loaded, and analysis progresses.
```{r txImport, eval=TRUE}
# read in the study design ----
targets <- read_tsv("./Data/S_stercoralis/Study_Design/SstercoralisRNAseq_study_design.txt",
                    na = c("", "NA", "na"))
# create file paths to the abundance files generated by Kallisto 
# using the 'file.path' function
path <- file.path("./Data/S_stercoralis/Reads",
                  targets$sample, 
                  "abundance.tsv")

# get annotations using organism-specific package ----
Tx.Ss <- getBM(attributes=c('wbps_transcript_id',
                            'wbps_gene_id'),
               # grab the ensembl annotations for Wormbase Parasite genes
               mart = useMart(biomart="parasite_mart", 
                              dataset = "wbps_gene", 
                              host="https://parasite.wormbase.org", 
                              port = 443),
               filters = c('species_id_1010'),
               useCache = FALSE,
               value = list('ststerprjeb528')) %>%
  as_tibble() %>%
  #we need to rename the columns retreived from biomart
  dplyr::rename(target_id = wbps_transcript_id,
                gene_name = wbps_gene_id) 


# import Kallisto transcript counts into R using Tximport ----
# copy the abundance files to the working directory and 
# rename so that each sample has a unique name
Txi_gene <- tximport(path, 
                     type = "kallisto", 
                     tx2gene = Tx.Ss[,1:2], 
                     txOut = FALSE,
                     countsFromAbundance = "lengthScaledTPM",
                     ignoreTxVersion = FALSE)

# Save the raw transcript counts ----
save(Txi_gene,
     file = file.path("./Data/S_stercoralis",
                      "SsRNAseq_TPM"))
```

## Gene Annotation 
Import gene annotation information for all genes from multiple species, including:

  * UniProtKB number
  * Interpro terms
  * GO terms
  * general Description information using biomart.

```{r geneAnnotation}
# Introduction to this chunk -----------
# This chunk imports gene annotation information using WBPS BiomaRT
# It will generate and save a table.

# Get gene information from BiomaRT and filter -----
species_list <- tibble(species = c('caelegprjna13758', 'cabrigprjna10731', 'cabrenprjna20035', 'caremaprjna53967', 'cajapoprjna12591'))

for (x in species_list$species) {
  comparison.attributes <- dplyr::filter(species_list, species!= x ) %>%
  dplyr::mutate(geneID = paste0(species, "_gene"), geneName = paste0(species, "_gene_name"), percID = paste0(species, "_homolog_perc_id"))

Annt.temp <- getBM(attributes=c('wbps_gene_id', 
                                'external_gene_id',
                                'description',
                                comparison.attributes$geneID[[1]],
                                comparison.attributes$geneName[[1]],
                                comparison.attributes$percID[[1]],
                                comparison.attributes$geneID[[2]],
                                comparison.attributes$geneName[[2]],
                                comparison.attributes$percID[[2]],
                                comparison.attributes$geneID[[3]],
                                comparison.attributes$geneName[[3]],
                                comparison.attributes$percID[[3]],
                                comparison.attributes$geneID[[4]],
                                comparison.attributes$geneName[[4]],
                                comparison.attributes$percID[[4]]
                                ),
                     # grab the annotations from WormBase ParaSite
                     mart = useMart(biomart="parasite_mart", 
                                    dataset = "wbps_gene", 
                                    host="https://parasite.wormbase.org", 
                                    port = 443),
                     filters = 'species_id_1010',
                     useCache = F,
                     value = x) %>%
  as_tibble(.name_repair = "unique")
  #rename columns 
  Annt.temp <- Annt.temp%>%
  tidyr::unite("GS4_homologID", 14, 13, sep = " | ", remove = T) %>%
  tidyr::unite("GS3_homologID", 11, 10, sep = " | ", remove = T) %>%
  tidyr::unite("GS2_homologID", 8, 7, sep = " | ", remove = T) %>%
  tidyr::unite("GS1_homologID", 5, 4, sep = " | ", remove = T) %>%
  dplyr::rename(geneID = "Gene stable ID",
                geneName = "Gene name",
                Description = "Gene description",
                GS1_percent_homology = "% identity...6",
                GS2_percent_homology = "% identity...9",
                GS3_percent_homology = "% identity...12",
                GS4_percent_homology = "% identity...15",
  ) %>%
  dplyr::group_by(geneID)

# Remove source code to shorten the description
Annt.temp <- Annt.temp 
Annt.temp$Description <- Annt.temp$Description %>%
  str_replace_all(string = ., 
                  pattern = "  \\[Source:.*\\]", 
                  replacement = "")

# Replace empty string values with NAs
Annt.temp[Annt.temp == " | "]<-NA

# Remove any duplications in the possible homolog matches. 
# Select based on highest % homology.
# Give fake value here to make sure genes 
# without homologs aren't filtered out
Annt.temp$GS1_percent_homology[
  is.na(Annt.temp$GS1_percent_homology)] <- 1000 
Annt.temp$GS2_percent_homology[
  is.na(Annt.temp$GS2_percent_homology)] <- 1000
Annt.temp$GS3_percent_homology[
  is.na(Annt.temp$GS3_percent_homology)] <- 1000
Annt.temp$GS4_percent_homology[
  is.na(Annt.temp$GS4_percent_homology)] <- 1000

Annt.temp <-Annt.temp %>%
  slice_max(n = 1, order_by = GS1_percent_homology, 
            with_ties = FALSE) %>%
  slice_max(n = 1, order_by = GS2_percent_homology, 
            with_ties = FALSE) %>%
  slice_max(n = 1, order_by = GS3_percent_homology, 
            with_ties = FALSE) %>%
  slice_max(n = 1, order_by = GS4_percent_homology, 
            with_ties = FALSE)

Annt.temp$GS1_percent_homology[
  Annt.temp$GS1_percent_homology == 1000] <- NA
Annt.temp$GS2_percent_homology[
  Annt.temp$GS2_percent_homology == 1000]<- NA
Annt.temp$GS3_percent_homology[
  Annt.temp$GS3_percent_homology == 1000]<- NA
Annt.temp$GS4_percent_homology[
  Annt.temp$GS4_percent_homology == 1000]<- NA

output.name <- paste0(x, '_geneAnnotations')
save(annotations,
     file = file.path(output.path,
                      output.name))
}



```

## Generate Digital Gene Expression List  
Next we generate a digital gene expression list that could be easily shared/loaded for downstream filtering/normalization. This code chunk generates a scatter plot of unfiltered and non-normalized transcripts per million data.  
```{r generateDGE, eval=TRUE}
# Goals of this chunk:
# Generate a digital gene expression list 
# that could be easily shared/loaded for downstream filtering/normalization

# Load data & study design ----
load(file = file.path("../Data/S_stercoralis",
                      "SsRNAseq_TPM"))

targets <- read_tsv("../Data/S_stercoralis/Study_Design/SstercoralisRNAseq_study_design.txt",
                    na = c("", "NA", "na"))

# Generate and plot summary stats for the data ----
myTPM.stats <- transform(Txi_gene$abundance, 
                         SD=rowSds(Txi_gene$abundance), 
                         AVG=rowMeans(Txi_gene$abundance),
                         MED=rowMedians(Txi_gene$abundance))

# produce a scatter plot of the transformed data
p1<-ggplot(myTPM.stats) + 
  aes(x = SD, y = MED) +
  geom_point(shape=16, size=2, alpha = 0.2) +
  geom_smooth(method=lm) +
  #geom_hex(show.legend = FALSE) +
  labs(y="Median", x = "Standard deviation",
       title = "S. stercoralis: Transcripts per million (TPM)",
       subtitle="unfiltered, non-normalized data",
       caption="S. stercoralis RNA-seq Datasets") +
  theme_bw()
p1

# make a Digital Gene Expression list using the raw counts and plot ----
myDGEList <- DGEList(Txi_gene$counts, 
                     samples = targets$sample, 
                     group = targets$group,
                     genes = annotations)

```


## Data Filtering and Normalization  
The goal of this chunk is to:

  1. Filter and normalize data
  2. Use `ggplot2` to visualize the impact of filtering and normalization on the data.
  
```{r dataWrangling.1, eval=TRUE}
# Goals of this chunk:
# 1 - Filter and normalize data
# 2 - use ggplot2 to visualize the impact of filtering and 
# normalization on the data.

# Notes:
# recall that abundance data are TPM, while the counts are 
# read counts mapping to each gene or transcript

# calculate and plot log2 counts per million ----

# Generate life stage IDs
ids <- rep(cbind(targets$group), 
           times = nrow(myDGEList$counts)) %>%
  as_factor()

# use the 'cpm' function from EdgeR to get log2 counts per million
# then coerce into a tibble
log2.cpm.df.pivot <-cpm(myDGEList, log=TRUE) %>%
  as_tibble(rownames = "geneID") %>%
  setNames(nm = c("geneID", targets$sample)) %>%
  pivot_longer(cols = -geneID, 
               names_to = "samples", 
               values_to = "expression") %>% 
  add_column(life_stage = ids)

# plot the pivoted data
p2 <- ggplot(log2.cpm.df.pivot) +
  aes(x=samples, y=expression, fill=life_stage) +
  geom_violin(trim = FALSE, show.legend = T, alpha= 0.7) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 20, 
               size = 2, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "sample",
       title = "S. stercoralis: Log2 Counts per Million (CPM)",
       subtitle="unfiltered, non-normalized",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw() +
  scale_fill_brewer(palette = "Dark2") +
  coord_flip()
```

### Plot of unfiltered, non-normalized log2CPM data by life stage  

```{r dataWrangling.2}
p2

# Filter the data ----

# filter genes/transcripts with low counts
# how many genes had more than 1 CPM (TRUE) in at least n samples
# Note: The cutoff "n" is adjusted for the number of 
# samples in the smallest group of comparison.
keepers <- cpm(myDGEList) %>%
  rowSums(.>1)>=3

myDGEList.filtered <- myDGEList[keepers,]

ids.filtered <- rep(cbind(targets$group), 
                    times = nrow(myDGEList.filtered)) %>%
  as_factor()

log2.cpm.filtered.df.pivot <- cpm(myDGEList.filtered, log=TRUE) %>%
  as_tibble(rownames = "geneID") %>%
  setNames(nm = c("geneID", targets$sample)) %>%
  pivot_longer(cols = -geneID,
               names_to = "samples",
               values_to = "expression") %>%
  add_column(life_stage = ids.filtered)

p3 <- ggplot(log2.cpm.filtered.df.pivot) +
  aes(x=samples, y=expression, fill=life_stage) +
  geom_violin(trim = FALSE, show.legend = T, alpha= 0.7) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 20, 
               size = 2, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "sample",
       title = "S. stercoralis: Log2 Counts per Million (CPM)",
       subtitle="filtered, non-normalized",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw() +
  scale_fill_brewer(palette = "Dark2") +
  coord_flip()
```

### Plot of filtered, non-normalized log2CPM data by life stage  

```{r dataWrangling.3}
p3

# Look at the genes excluded by the filtering step ----
# just to check that there aren't any with 
# high expression that are in few samples
# Discarded genes
myDGEList.discarded <- myDGEList[!keepers,]

ids.discarded <- rep(cbind(targets$group), 
                     times = nrow(myDGEList.discarded)) %>%
  as_factor()

log2.cpm.discarded.df.pivot <- cpm(myDGEList.discarded, log=F) %>%
  as_tibble(rownames = "geneID") %>%
  setNames(nm = c("geneID", targets$sample)) %>%
  pivot_longer(cols = -geneID,
               names_to = "samples",
               values_to = "expression") %>%
  add_column(life_stage = ids.discarded)

p.discarded <- ggplot(log2.cpm.discarded.df.pivot) +
  aes(x=samples, y=expression, color=life_stage) +
  geom_jitter(alpha = 0.3, show.legend = T)+
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 20, 
               size = 2, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="expression", x = "sample",
       title = "S. stercoralis: Counts per Million (CPM)",
       subtitle="genes excluded by low count filtering step, non-normalized",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw() +
  scale_color_brewer(palette = "Dark2") +
  coord_flip()

```

### Plot of genes discarded by low-copy filtering step  
The low copy number filtering step excluded a total of `r dim(myDGEList.discarded)[[1]]` genes.  

```{r dataWrangling.4}
p.discarded

# # Carry out GO enrichment of discarded gene set using gProfiler2 ----
# discarded.geneID <- unique(log2.cpm.discarded.df.pivot$geneID)
# gost.res <- gost(list(Discarded_genes = discarded.geneID), 
#                  organism = "ststerprjeb528", correction_method = "fdr")
# gostplot(gost.res, interactive = T, capped = T)

# Genes that are above 1 cpm
log2.cpm.discarded.df.pivot %>%
  dplyr::filter(expression > 1)

# Generate a matrix of discarded genes and their raw counts ----
discarded.gene.df <- log2.cpm.discarded.df.pivot %>%
  pivot_wider(names_from = c(life_stage, samples), 
              names_sep = "-", 
              values_from = expression, 
              id_cols = geneID) 
  
# Normalize the data using a between samples normalization ----
# Source for TMM sample normalization here:
# https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-3-r25
myDGEList.filtered.norm <- calcNormFactors(myDGEList.filtered, method = "TMM")

log2.cpm.filtered.norm <- cpm(myDGEList.filtered.norm, log=TRUE) 

log2.cpm.filtered.norm.df<- cpm(myDGEList.filtered.norm, log=TRUE) %>%
  as_tibble(rownames = "geneID") %>%
  setNames(nm = c("geneID", targets$sample))

log2.cpm.filtered.norm.df.pivot<-log2.cpm.filtered.norm.df %>%
  pivot_longer(cols = -geneID,
               names_to = "samples",
               values_to = "expression") %>%
  add_column(life_stage = ids.filtered)

p4 <- ggplot(log2.cpm.filtered.norm.df.pivot) +
  aes(x=samples, y=expression, fill=life_stage) +
  geom_violin(trim = FALSE, show.legend = T, alpha = 0.7) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 20, 
               size = 2, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "sample",
       title = "S. stercoralis: Log2 Counts per Million (CPM)",
       subtitle="filtered, TMM normalized",
       caption=paste0("produced on ", Sys.time())) +
  theme_bw() +
  scale_fill_brewer(palette = "Dark2") +
  coord_flip()

```

### Plot of filtered, normalized log2CPM data by life stage    
```{r dataWrangling.5}
p4

```

## Compute Variance-Stabilized DGEList Object  
This chunk uses a DGEList of filtered and normalized abundance data. It will fit data to a linear model for responsively detecting differentially expressed genes (DEGs).   
```{r vDEGList, eval=TRUE}
# Introduction to this chunk ----
# This chunk uses a DGEList of filtered and normalized abundance data
# It will fit data to a linear model for responsively detecting 
# differentially expressed genes (DEGs)

# Set up the design matrix ----
# no intercept/blocking for matrix, comparisons across group
group <- factor(targets$group)
design <- model.matrix(~0 + group) 
colnames(design) <- levels(group)

# NOTE: To handle a 'blocking' design' or a batch effect, use:
# design <- model.matrix(~block + treatment)

# Model mean-variance trend and fit linear model to data ----
# Use VOOM function from Limma package to model the mean-variance relationship
# produces a variance-stabilized DGEList, that include precision 
# weights for each gene to try and control for heteroscedasity.
# transforms count data to log2-counts per million
# Outputs: E = normalized expression values on the log2 scale
v.DEGList.filtered.norm <- voom(counts = myDGEList.filtered.norm, 
                                design = design, plot = T)
colnames(v.DEGList.filtered.norm)<-targets$sample
colnames(v.DEGList.filtered.norm$E) <- paste(targets$group, 
                                             targets$sample,sep = '-')
```

## Save Data and Annotations  
Finally, we save data and annotations generated in code chunks above. We can separate these saving actions into two groups:

1. Data saved for downstream offline analyses, including the `SsRNAseq_data_preprocessed` file which saves filtered, normalized (but not voom adjusted) log2CPM values, gene annotation information, and sample information.
2. Files that are required inputs to the *Strongyloides* RNA-seq Browser App, including:

    i) a gene annotation R object (`Ss_geneAnnotations`)
    ii)  the variance-stabilized vDGEList, saved as an R object (`Ss_vDGEList`)
    iii) a matrix of discarded genes and their raw counts (`SsRNAseq_discardedGene_counts.csv`) - this data is downloadable from within the Browser App
    iv) a matrix of variance-stabilized gene expression data, extracted from the vDGEList (`SsRNAseq_log2cpm_filtered_norm_voom.csv`) - this data is downloadable from within the Browser App
    
These files are saved in an Outputs folder; in order to make them accessible to a local version of the Shiny browser they need to be moved to appropriate subfolders within the App folder - the www sub folder (for .csv files) or the Data subfolder (for R objects). Stable copies are already located within those folders and do not need to be replaced unless the pre-processing steps change.    
  
```{r saveBaseData, eval = TRUE}

# Check for presence of output folder, generate if it doesn't exist
output.path <- "../Outputs"
if (!dir.exists(output.path)){
  dir.create(output.path)
}

# Save full gene annotations ----
# This object is required for the Shiny Browser
save(annotations,
file = file.path(output.path,
                        "Ss_geneAnnotations"))

# Save a matrix of discarded genes and their raw counts ----
discarded.gene.df %>%    
write.csv(file = file.path(output.path,
                           "SsRNAseq_discardedGene_counts.csv"))

# Save matrix of genes and their filtered, normalized, voom-transformed counts ----
# This is the count data that underlies the differential expression analyses in the Shiny app. 
# Saving it here so that users of the app can access the input information.
write.csv(v.DEGList.filtered.norm$E, 
          file = file.path(output.path,
                           "SsRNAseq_log2cpm_filtered_norm_voom.csv"))

# Save v.DEGList ----
# This file will be imported into Shiny App 

save(v.DEGList.filtered.norm,
     file = file.path(output.path,
                      "Ss_vDGEList")
)


# This data is required for downstream analyses in this file. 
# It enables users to not have to re-import and re-align 
# raw read files every time the code is run.

SsRNAseq.preprocessed.data <- list(targets = targets,
                                   annotations = annotations,
                                   log2.cpm.filtered.norm = log2.cpm.filtered.norm,
                                   myDGEList.filtered.norm = myDGEList.filtered.norm
)
save(SsRNAseq.preprocessed.data,
     file = file.path(output.path,
                      "SsRNAseq_data_preprocessed"))

```

# Appendix I : All code for this report  
```{r ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE}
```

# Appendix II: Session Info
```{r sessionInfo, message = TRUE}
sessionInfo()
```
